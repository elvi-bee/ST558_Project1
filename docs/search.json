[
  {
    "objectID": "ST558_Project1.html",
    "href": "ST558_Project1.html",
    "title": "ST 558 Project 1",
    "section": "",
    "text": "The goals of this project are to:\n\nWrite a function to query an API with user-selected data, process and manipulate the data retrieved, and return it as a tibble\nWrite generic functions to summarize and plot the data\nInvestigate something interesting from the data using the API, summarize, and plot functions"
  },
  {
    "objectID": "ST558_Project1.html#objectives",
    "href": "ST558_Project1.html#objectives",
    "title": "ST 558 Project 1",
    "section": "",
    "text": "The goals of this project are to:\n\nWrite a function to query an API with user-selected data, process and manipulate the data retrieved, and return it as a tibble\nWrite generic functions to summarize and plot the data\nInvestigate something interesting from the data using the API, summarize, and plot functions"
  },
  {
    "objectID": "ST558_Project1.html#data",
    "href": "ST558_Project1.html#data",
    "title": "ST 558 Project 1",
    "section": "Data",
    "text": "Data\nWe are using the Public Use Microdata Sample (PUMS) Census API. According to the US Census Bureau, the PUMS files are a broad set of records from individuals and dwellings, ranging from years 2005 to 2019 and 2021 to 2022. Variables used in this project include:\n\nNumeric Variables\n\nPWGTP (PUMS Person Weight)\nAGEP (Age)\nGASP (Gas cost, monthly)\nGRPIP (Gross rent as a percentage of household income, past 12 months)\nJWAP (Time of arrival at work - hour and minute)\nJWDP (Time of departure for work - hour and minute)\nJWMNP (Travel time to work)\n\nCategorical Variables\n\nFER (Gave birth to child within the past 12 months)\nHHL (Household language)\nHISPEED (Broadband/high speed Internet service)\nJWTRNS (Means of transportation to work)\nSCH (School enrollment)\nSCHL (Educational attainment)\nSEX (Sex)"
  },
  {
    "objectID": "ST558_Project1.html#api-function",
    "href": "ST558_Project1.html#api-function",
    "title": "ST 558 Project 1",
    "section": "API Function",
    "text": "API Function\nThe purpose of the first function is to query the API with user-selected data, process and manipulate the data retrieved, and return it as a tibble. The function was constructed step-by-step as follows:\n\nSteps to build API Function\n\nQuerying the API with a given example URL using the usual process for querying an API\n\n\n# a simple API call\nURL_ids &lt;- \"https://api.census.gov/data/2023/acs/acs5/pums?get=SEX,PWGTP,MAR&for=state:1&SCHL=24\"\nid_info &lt;- httr::GET(URL_ids)\n#str(id_info)\nparsed &lt;-fromJSON(rawToChar(id_info$content))\n# use first row as columns headers\nPUMS20235Y &lt;- as_tibble(parsed[-1, ], .name_repair = ~ parsed[1, ])\nPUMS20235Y\n\n\nWriting a helper function to take what is returned by GET() in the API query and making it into a tibble\n\n\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(tibble)\nlibrary(stringr)\n\n  URL_ids &lt;- \"https://api.census.gov/data/2023/acs/acs5/pums?get=SEX,PWGTP,MAR&for=state:1&SCHL=24\"\n  id_info &lt;- httr::GET(URL_ids)\n\ncreate_tibble_helper &lt;- function(id_info) {\n  parsed &lt;-fromJSON(rawToChar(id_info$content))\n  # obtain columns headers from first row\n  return(as_tibble(parsed[-1, ], .name_repair = ~ parsed[1, ]))\n}\n\n# test function: a tibble is created with helper function\ntest_tibble1 &lt;- create_tibble_helper(id_info)\nhead(test_tibble1)\n\n# A tibble: 6 × 5\n  SEX   PWGTP MAR   SCHL  state\n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 2     4     3     24    01   \n2 1     20    1     24    01   \n3 2     4     1     24    01   \n4 1     27    1     24    01   \n5 1     26    1     24    01   \n6 1     14    1     24    01   \n\n\n\nWriting a function to query the API with user-selected survey year (default value of 2022), checking to ensure that the user-selected year is valid (between 2010 and 2022)\n\n\n# function that builds API URL with user input for year\nAPI_URL_builder &lt;- function(year = 2022){\n  #code that takes user inputs and concatenates them into a string that becomes the URL, year must be between 2010 - 2022 and cannot be a decimal\n  if ( year &lt; 2010 | year &gt; 2022 | year %% 1 != 0){\n     stop(\"Please enter a valid year between 2010 and 2022.\")\n     return(NA)\n   }\n  API_URL &lt;- paste0(\"https://api.census.gov/data/\", year, \"/acs/acs1/pums?get=SEX,PWGTP,MAR&for=state:1\" )\n  return(API_URL)\n}\n  \n# test function: URLs for 2015 and 2021\napi_test_year1 &lt;- API_URL_builder(2015)\nprint(api_test_year1)\n\n[1] \"https://api.census.gov/data/2015/acs/acs1/pums?get=SEX,PWGTP,MAR&for=state:1\"\n\napi_test_year2 &lt;- API_URL_builder(2021)\nprint(api_test_year2)\n\n[1] \"https://api.census.gov/data/2021/acs/acs1/pums?get=SEX,PWGTP,MAR&for=state:1\"\n\n\n\nUpdating the API function with user-selected numerical variables entered as a vector (user options: AGEP, GASP, GRPIP, JWAP (time), JWDP (time), and JWMNP; default values: AGEP, PWGTP; PWGTP always returned), checking to ensure that user-entered variables are valid\nUpdating the API function with user-selected categorical variables entered as a vector (user options: FER, HHL, HISPEED, JWTRNS, SCH, SCHL, and SEX; default value: SEX), checking to ensure that user-entered variables are valid\n\n\n# function that builds API URL with user input for numeric variables\n\n\nAPI_Year_NumericVar_Builder &lt;- function(year = 2022, \n                                        numvars = \"AGEP\", \n                                        catvars = \"SEX\"){\n      if ( year &lt; 2010 | year &gt; 2022 | year %% 1 != 0){\n     stop(\"Please enter a valid year between 2010 and 2022.\")\n     #return(NA)\n      }\n  \n      # add numeric and categorical variable user options\n      var_options &lt;- c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWAP\",\"JWDP\",\"JWMNP\",\"SEX\", \"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\")\n      \n      #make sure all user choices are in allowed list of options\n      if (!all(numvars %in% var_options)) \n        stop(\"Please enter a valid numeric variable.\")\n      if (length(numvars) &lt; 1) \n        stop(\"Include at least one numeric variable besides PWGTP.\")\n      numvars_comb &lt;- paste(numvars, collapse = \",\")\n      \n      # add categorical variable user options\n      #make sure all user choices are in allowed list of options\n      if (!all(catvars %in% var_options)) \n        stop(\"Please enter a valid categorical variable.\")\n      catvars_comb &lt;- paste(catvars, collapse = \",\")\n  #numvars = c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWAP\", \"JWDP\", \"JWMNP\")\n  API_URL &lt;- paste0(\"https://api.census.gov/data/\", year, \"/acs/acs1/pums?get=PWGTP,\",numvars_comb,\",\",catvars_comb,\"&for=state:1\" )\n\n  return(API_URL)\n}\n\n# test function - API URLs are created from user specified num vars and cat vars\napi_test_vars1 &lt;- API_Year_NumericVar_Builder(2015, \n                            numvars = c(\"AGEP\",\"GRPIP\"), \n                            catvars = c(\"FER\", \"HHL\"))\nprint(api_test_vars1)\n\n[1] \"https://api.census.gov/data/2015/acs/acs1/pums?get=PWGTP,AGEP,GRPIP,FER,HHL&for=state:1\"\n\n# test function: if no numeric var is specified, the default is AGEP (and PWGTP is always returned)\napi_test_vars2 &lt;- API_Year_NumericVar_Builder(2017,\n                            catvars= c(\"HISPEED\"))\n\nprint(api_test_vars2)\n\n[1] \"https://api.census.gov/data/2017/acs/acs1/pums?get=PWGTP,AGEP,HISPEED&for=state:1\"\n\n# test function: if no categorical var is specified, the default is SEX\napi_test_vars3 &lt;- API_Year_NumericVar_Builder(2016, \n                            numvars = c(\"GASP\", \"JWAP\"))\n\nprint(api_test_vars3)\n\n[1] \"https://api.census.gov/data/2016/acs/acs1/pums?get=PWGTP,GASP,JWAP,SEX&for=state:1\"\n\n\n\nUpdating the API function with user-selected geography levels (user options: all, region, division, state; default value: all), checking to ensure that user-entered levels are valid\nUpdating the API function with optional, user-selected geographic subsetting for specific regions, divisions, or states (user options for regions: 1 to 4, *; default region value *) (user options for divisions: 1 to 9, *; default division value *) (user options for states: 01 to 02, 04 to 06, 08 to 13, 15 to 42, 44 to 51, 53 to 56, *; default state value 08 (Colorado)), checking for valid inputs and combinations of inputs\n\n\n# function that builds API URL with user input for year and numeric, categorical, and geographic variable options\n\n\nAPI_URL_Builder &lt;- function(year = 2022, \n                            numvars = \"AGEP\", \n                            catvars = \"SEX\", \n                            geo_level = \"state\",\n                            geo_subset = \"08\"){\n      if ( year &lt; 2010 | year &gt; 2022 | year %% 1 != 0){\n     stop(\"Please enter a valid year between 2010 and 2022.\")\n      }\n  \n      # add numeric and categorical variable user options\n      var_options &lt;- c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWAP\",\"JWDP\",\"JWMNP\",\"SEX\", \"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\")\n      \n      #make sure all user choices are in allowed list of options\n      if (!all(numvars %in% var_options)) \n        stop(\"Please enter a valid numeric variable.\")\n      if (length(numvars) &lt; 1) \n        stop(\"Include at least one numeric variable besides PWGTP.\")\n\n      numvars_comb &lt;- paste(numvars, collapse = \",\")\n      \n      # add categorical variable user options\n      # make sure all user choices are in allowed list of options\n      if (!all(catvars %in% var_options)) \n        stop(\"Please enter a valid categorical variable.\")\n      catvars_comb &lt;- paste(catvars, collapse = \",\")\n      \n      # add Geographic user options\n      \n      # allowable region, division, and state codes\n      region_code_options &lt;-c(\"1\",\"2\",\"3\",\"4\", \"*\")\n      division_code_options &lt;- c(\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\", \"*\")\n      state_code_options &lt;- c(\"01\",\"49\",\"21\",\"26\",\"29\",\"32\",\"34\",\"08\",\"51\",\"39\",\n                          \"02\",\"46\",\"04\",\"06\",\"55\",\"15\",\"22\",\"30\",\"47\",\"48\",\n                          \"09\",\"50\",\"53\",\"17\",\"20\",\"35\",\"36\",\"10\",\"11\",\"12\",\n                          \"56\",\"16\",\"25\",\"27\",\"42\",\"45\",\"13\",\"23\",\"24\",\"28\",\n                          \"37\",\"41\",\"05\",\"19\",\"31\",\"33\",\"44\",\"54\",\"18\",\"38\",\n                          \"40\", \"*\")\n                          #PR 72 not included\n      \n      #specify the geo_levels, with default of all\n      geo_level_options &lt;- c(\"all\", \"region\", \"division\", \"state\")\n      # Check that the value specified by the user is one of the above values\n      if (!all(geo_level %in% geo_level_options)) \n        stop(\"Please enter a valid Geography.\")\n      \n      # if geo_subset is missing, set defaults\nif (missing(geo_subset) | length(geo_subset) == 0 | geo_subset == \"\") {\n  if (geo_level == \"state\") geo_subset &lt;- \"08\"\n  if (geo_level == \"region\") geo_subset &lt;- \"*\"\n  if (geo_level == \"division\") geo_subset &lt;- \"*\"\n}\n\n      if (geo_level == \"region\" && !geo_subset %in% region_code_options) {\n  stop(\"Not a valid Region code. Region code must be 1–4\")\n      }\n      if (geo_level == \"division\" && !geo_subset %in% division_code_options) {\n  stop(\"Not a valid Division code. Division code must be 1–9\")\n      }\n      if (geo_level == \"state\" && !geo_subset %in% state_code_options) {\n  stop(\"Not a valid State code\")\n}\n      # build URL\n  API_URL &lt;- paste0(\"https://api.census.gov/data/\", year, \"/acs/acs1/pums?get=PWGTP,\",numvars_comb,\",\",catvars_comb,\"&for=\",geo_level, \":\", geo_subset)\n  \n  return(API_URL)\n}\n\n# test function: user can specify region, division, or state\napi_test_geo1 &lt;- API_URL_Builder(\n  year   = c(2022),\n  numvars = c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWMNP\"),\n  catvars = c(\"JWAP\", \"JWDP\",\"FER\",\"HHL\",\"HISPEED\",\"JWTRNS\",\"SCH\",\"SCHL\",\"SEX\"),\n  geo_level = \"region\",\n  geo_subset = \"2\"\n)\nprint(api_test_geo1)\n\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,AGEP,GASP,GRPIP,JWMNP,JWAP,JWDP,FER,HHL,HISPEED,JWTRNS,SCH,SCHL,SEX&for=region:2\"\n\napi_test_geo2 &lt;- API_URL_Builder(\n  year   = c(2022),\n  numvars = c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWMNP\"),\n  catvars = c(\"JWAP\", \"JWDP\",\"FER\",\"HHL\",\"HISPEED\",\"JWTRNS\",\"SCH\",\"SCHL\",\"SEX\"),\n  geo_level = \"division\",\n  geo_subset = \"*\"\n)\nprint(api_test_geo2)\n\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,AGEP,GASP,GRPIP,JWMNP,JWAP,JWDP,FER,HHL,HISPEED,JWTRNS,SCH,SCHL,SEX&for=division:*\"\n\n# test function: outputs default of state 08 when no state is selected\napi_test_geo3 &lt;- API_URL_Builder(\n  year   = c(2022),\n  numvars = c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWMNP\"),\n  catvars = c(\"JWAP\", \"JWDP\",\"FER\",\"HHL\",\"HISPEED\",\"JWTRNS\",\"SCH\",\"SCHL\",\"SEX\"),\n  geo_level = \"state\",\n  geo_subset = \"\"\n)\nprint(api_test_geo3)\n\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,AGEP,GASP,GRPIP,JWMNP,JWAP,JWDP,FER,HHL,HISPEED,JWTRNS,SCH,SCHL,SEX&for=state:08\"\n\n\n\n\nFinalizing the API Builder Function\nFinalizing our API builder involved the following three tasks:\n\nWriting an additional function largely based on functionality of the first function. The additional function, which we refer to as Multi-Year API Builder, allows user specification of multiple years of survey data entered as a vector in addition to all options enumerated above, calling above single-year function as needed and combining data into a single tibble with year variable added\nDeveloping two helper functions to (1) get PUMS metadata variables for user-selected years, and (2) join metadata labels to downloaded PUMS data to extract label values for dates\nUpdating API function to clean/wrangle the data set, assigning data types of numerical, categorical, and time as appropriate, using PUMS metadata to obtain metadata labels for numerical and categorical data\n\n\n# load libraries\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(tibble)\nlibrary(stringr)\nlibrary(lubridate)\n\n\nAttaching package: 'lubridate'\n\n\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n\n#_________________________________\n# helper function: parse GET to create tibble with header row as names\n  create_tibble_helper &lt;- function(id_info) {\n    parsed &lt;- fromJSON(rawToChar(id_info$content))\n    as_tibble(parsed[-1, ], .name_repair = ~ parsed[1, ])\n  }\n\n#_________________________________\n# helper function for PUMS metadata - builds variables.json URL from user inputs\nget_pums_metadata &lt;- function(year = 2022) {\n  metadata_url &lt;- paste0(\"https://api.census.gov/data/\", year, \"/acs/acs1/pums/variables.json\")\n  metadata_json_url &lt;- httr::GET(metadata_url)\n  fromJSON(rawToChar(metadata_json_url$content))\n}\n\n#_________________________________\n# helper function: get variable ids for joining metadata to data\n# input is json metadata and variable\nbuild_value_lookup &lt;- function(metadata, var) {\n  v &lt;- metadata$variables[[var]]\n  # skip if not coded values for numeric vars like AGEP\n  if (is.null(v) || is.null(v$values) || is.null(v$values$item)) return(NULL)\n  # make tibble with json metadata column names\n  lookup &lt;- tibble(\n    code  = names(v$values$item),\n    label = unlist(v$values$item, use.names = FALSE)\n  )\n  # rename added label columns\n  names(lookup) &lt;- c(var, paste0(var, \"_label\"))\n  lookup\n}\n\n#_______________________________________\n# function to join labels to categorical variables in df\nlabel_categoricals &lt;- function(df, metadata, catvars) {\n  if (missing(catvars) || is.null(catvars) || length(catvars) == 0) return(df)\n  # only keep categorical vars that are actually in df\n  vars &lt;- intersect(catvars, names(df))\n  if (length(vars) == 0) return(df)\n  out &lt;- df\n  for (var in vars) {\n    # build lookup for this var\n    lk &lt;- build_value_lookup(metadata, var)  # &lt;- note: _simple\n    if (is.null(lk)) next\n    # ensure key types match\n    out[[var]] &lt;- as.character(out[[var]])\n    lk[[var]]  &lt;- as.character(lk[[var]])\n    # pad time codes to 3 chars if needed\n  if (var %in% c(\"JWAP\",\"JWDP\")) {\n    out[[var]] &lt;- stringr::str_pad(out[[var]], 3, pad = \"0\")\n    lk[[var]]  &lt;- stringr::str_pad(lk[[var]], 3, pad = \"0\")\n  }\n    # join VAR_label column\n    out &lt;- dplyr::left_join(out, lk, by = var)\n  }\n  out\n}\n\n#_______________________________\n# Single-Year API URL Builder Function\n\nAPI_URL_Builder &lt;- function(year = 2022, numvars = \"AGEP\", catvars = \"SEX\",\n                            geo_level = \"state\", geo_subset = \"08\") {\n  if ( year &lt; 2010 | year &gt; 2022 | year %% 1 != 0){\n    stop(\"Please enter a valid year between 2010 and 2022.\")\n  }\n\n  # add numeric and categorical variable user options\n  var_options &lt;- c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWAP\",\"JWDP\",\"JWMNP\",\"SEX\",\"FER\",\"HHL\",\n                   \"HISPEED\",\"JWTRNS\",\"SCH\",\"SCHL\")\n\n  # check numeric user options are valid\n  if (!all(numvars %in% var_options))\n    stop(\"Please enter a valid numeric variable.\")\n  if (length(numvars) &lt; 1)\n    stop(\"Include at least one numeric variable besides PWGTP.\")\n  if (!all(catvars %in% var_options))\n    stop(\"Please enter a valid categorical variable.\")\n\n  numvars_comb &lt;- paste(numvars, collapse = \",\")\n  catvars_comb &lt;- paste(catvars, collapse = \",\")\n\n  # allowable geography options\n  region_code_options   &lt;- c(\"1\",\"2\",\"3\",\"4\",\"*\")\n  division_code_options &lt;- c(\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"*\")\n  state_code_options    &lt;- c(\"01\",\"49\",\"21\",\"26\",\"29\",\"32\",\"34\",\"08\",\"51\",\"39\",\n                             \"02\",\"46\",\"04\",\"06\",\"55\",\"15\",\"22\",\"30\",\"47\",\"48\",\n                             \"09\",\"50\",\"53\",\"17\",\"20\",\"35\",\"36\",\"10\",\"11\",\"12\",\n                             \"56\",\"16\",\"25\",\"27\",\"42\",\"45\",\"13\",\"23\",\"24\",\"28\",\n                             \"37\",\"41\",\"05\",\"19\",\"31\",\"33\",\"44\",\"54\",\"18\",\"38\",\n                             \"40\",\"*\")\n\n  geo_level_options &lt;- c(\"all\", \"region\", \"division\", \"state\")\n  if (!all(geo_level %in% geo_level_options))\n    stop(\"Please enter a valid Geography.\")\n\n  if (missing(geo_subset) | length(geo_subset) == 0 | geo_subset == \"\") {\n    if (geo_level == \"state\") geo_subset &lt;- \"08\"\n    if (geo_level == \"region\") geo_subset &lt;- \"*\"\n    if (geo_level == \"division\") geo_subset &lt;- \"*\"\n  }\n\n  if (geo_level == \"region\"  & !geo_subset %in% region_code_options)\n    stop(\"Not a valid Region code. Region code must be 1–4\")\n  if (geo_level == \"division\" & !geo_subset %in% division_code_options)\n    stop(\"Not a valid Division code. Division code must be 1–9\")\n  if (geo_level == \"state\"   & !geo_subset %in% state_code_options)\n    stop(\"Not a valid State code\")\n\n  # Build URL\n  API_URL &lt;- paste0(\n    \"https://api.census.gov/data/\", year, \"/acs/acs1/pums?get=PWGTP,\",\n    numvars_comb, \",\", catvars_comb,\n    \"&for=\", geo_level, \":\", geo_subset\n  )\n\n  return(API_URL)\n}\n\n#_________________________________\n# Multi-Year API Builder Function\n\n# two lines below assign JWAP and JWDP to categorical so that metadata can be added after multi-year runs\nnumvars &lt;- c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWMNP\")\ncatvars &lt;- c(\"FER\",\"HHL\",\"HISPEED\",\"JWTRNS\",\"SCH\",\"SCHL\",\"SEX\",\"JWAP\",\"JWDP\")\n\nMultiYear_API_Builder &lt;- function(years, \n                                  numvars = \"AGEP\", \n                                  catvars = \"SEX\",\n                                  geo_level = \"state\", \n                                  geo_subset) {\n\n  \n\n  result_list &lt;- vector(\"list\", length(years))\n\n  for (i in seq_along(years)) {\n    y &lt;- years[i]\n\n    # build URL and pull data\n    url &lt;- API_URL_Builder(y, numvars, catvars, geo_level, geo_subset)\n    api_response &lt;- httr::GET(url)\n    httr::stop_for_status(api_response)\n\n    df &lt;- create_tibble_helper(api_response)\n    df$year &lt;- y\n\n    # get metadata for year\n    metadata &lt;- get_pums_metadata(y)\n\n    # add labels to user specified categorical variables\n    df &lt;- label_categoricals(df, metadata, catvars)\n\n    result_list[[i]] &lt;- df\n  }\n\n  final &lt;- dplyr::bind_rows(result_list)\n  class(final) &lt;- c(\"census\", class(final)) #make the tibble census-class\n  \n  #wrangle data\n  \n  # numerical data\n  for (i in seq_along(final)) {\n    if (colnames(final)[i] == \"PWGTP\") {\n    final$PWGTP &lt;- as.integer(final$PWGTP)\n    }\n    if (colnames(final)[i] == \"AGEP\") {\n      final$AGEP &lt;- as.integer(final$AGEP)\n    }\n    if (colnames(final)[i] == \"GASP\") {\n      final$GASP &lt;- as.integer(final$GASP)\n    }\n    if (colnames(final)[i] == \"GRPIP\") {\n      final$GRPIP &lt;- as.integer(final$GRPIP)\n    }\n    if (colnames(final)[i] == \"JWMNP\") { #this one is number of minutes\n      final$JWMNP &lt;- as.integer(final$JWMNP)\n    }\n  }\n  \n  # categorical data:\n  for (i in seq_along(final)) {\n    if (colnames(final)[i] == \"FER\") {\n    final$FER &lt;- as.factor(final$FER)\n    }\n    if (colnames(final)[i] == \"HHL\") {\n      final$HHL &lt;- as.factor(final$HHL)\n    }\n    if (colnames(final)[i] == \"HISPEED\") {\n      final$HISPEED &lt;- as.factor(final$HISPEED)\n    }\n    if (colnames(final)[i] == \"JWTRNS\") {\n      final$JWTRNS &lt;- as.factor(final$JWTRNS)\n    }\n    if (colnames(final)[i] == \"SCH\") {\n      final$SCH &lt;- as.factor(final$SCH)\n    }\n    if (colnames(final)[i] == \"SCHL\") {\n      final$SCHL &lt;- as.factor(final$SCHL)\n    }\n    if (colnames(final)[i] == \"SEX\") {\n      final$SEX &lt;- as.factor(final$SEX)\n    }\n  }\n  #________________________________________________\n  \n  # Time formatting\n  \n  # JWAP\n  \n  # runs if the label columns exist\nif (\"JWAP_label\" %in% names(final)) {\n  final &lt;- final |&gt;\n    mutate(\n      # start/end strings before and after 'to'\n      JWAPstart_str = sub(\"\\\\s+to.*$\", \"\", JWAP_label),\n      JWAPend_str   = sub(\".*to\\\\s+\",   \"\", JWAP_label),\n      # turn a.m./p.m. into AM/PM \n      JWAPstart_str = stringr::str_replace_all(JWAPstart_str, c(\"a\\\\.m\\\\.\" = \"AM\", \"p\\\\.m\\\\.\" = \"PM\")),\n      JWAPend_str   = stringr::str_replace_all(JWAPend_str,   c(\"a\\\\.m\\\\.\" = \"AM\", \"p\\\\.m\\\\.\" = \"PM\")),\n      # parse to times\n      JWAPstart_time = lubridate::parse_date_time(JWAPstart_str, orders = \"I:M p\", quiet = TRUE),\n      JWAPend_time   = lubridate::parse_date_time(JWAPend_str,   orders = \"I:M p\", quiet = TRUE),\n      # calculate midpoint\n      JWAP_midtime   = JWAPstart_time + (JWAPend_time - JWAPstart_time)/2,\n      # formatting\n      JWAP_mid_label = dplyr::if_else(is.na(JWAP_midtime), NA_character_, format(JWAP_midtime, \"%I:%M %p\"))\n    ) |&gt;\n    # delete intermediate columns\n    select(-dplyr::any_of(c(\"JWAPstart_time\",\"JWAPend_time\",\"JWAPstart_str\",\"JWAPend_str\",\n                            \"JWAP_midtime\",\"JWAP_label\")))\n}\n\n  # JWDP\n  \n  # runs if the label column exists\nif (\"JWDP_label\" %in% names(final)) {\n  final &lt;- final |&gt;\n    mutate(\n      # start/end strings before and after 'to'\n      JWDPstart_str = sub(\"\\\\s+to.*$\", \"\", JWDP_label),\n      JWDPend_str   = sub(\".*to\\\\s+\",   \"\", JWDP_label),\n      # turn a.m./p.m. into AM/PM \n      JWDPstart_str = stringr::str_replace_all(JWDPstart_str, c(\"a\\\\.m\\\\.\" = \"AM\", \"p\\\\.m\\\\.\" = \"PM\")),\n      JWDPend_str   = stringr::str_replace_all(JWDPend_str,   c(\"a\\\\.m\\\\.\" = \"AM\", \"p\\\\.m\\\\.\" = \"PM\")),\n      # parse to times\n      JWDPstart_time = lubridate::parse_date_time(JWDPstart_str, orders = \"I:M p\", quiet = TRUE),\n      JWDPend_time   = lubridate::parse_date_time(JWDPend_str,   orders = \"I:M p\", quiet = TRUE),\n      # calculate midpoint\n      JWDP_midtime   = JWDPstart_time + (JWDPend_time - JWDPstart_time)/2,\n      JWDP_mid_label = dplyr::if_else(is.na(JWDP_midtime), NA_character_, format(JWDP_midtime, \"%I:%M %p\"))\n    ) |&gt;\n    # delete intermediate columns\n    select(-dplyr::any_of(c(\"JWDPstart_time\",\"JWDPend_time\",\"JWDPstart_str\",\"JWDPend_str\",\n                            \"JWDP_midtime\",\"JWDP_label\")))\n}\n    return(final)\n}\n\nIn summary, the Multi-Year function takes in the following vectors:\n\nyear(s)\nnumeric variables\ncategorical variables\ngeographic level (including options specification for individual region, division, or state)\n\nFor each year in the sequence, the multi-year function runs the single year API Builder to construct the API call for the desired year(s), numeric variables, categorical variables, and geographic levels.\nThe finalized Multi-Year API Builder can be run as follows:\n\n# test function: test multi year function to include multiple years, user-specified variables, and time variables formatted to middle of time ranges\noutput_data &lt;- MultiYear_API_Builder(\n  years   = c(2021,2022),\n  numvars = c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWMNP\"),\n  catvars = c(\"JWAP\", \"JWDP\",\"FER\",\"HHL\",\"HISPEED\",\"JWTRNS\",\"SCH\",\"SCHL\",\"SEX\"),\n  geo_level = \"state\",\n  geo_subset = \"08\"\n)\nglimpse(output_data)\n\nRows: 117,972\nColumns: 25\n$ PWGTP          &lt;int&gt; 149, 99, 5, 12, 35, 59, 105, 69, 69, 30, 7, 27, 125, 6,…\n$ AGEP           &lt;int&gt; 29, 39, 21, 70, 33, 36, 93, 22, 18, 23, 67, 58, 52, 89,…\n$ GASP           &lt;int&gt; 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3…\n$ GRPIP          &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ JWMNP          &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 20, 0, 0, 0, 0, 0, 0, …\n$ JWAP           &lt;chr&gt; \"000\", \"000\", \"000\", \"000\", \"000\", \"000\", \"000\", \"000\",…\n$ JWDP           &lt;chr&gt; \"000\", \"000\", \"000\", \"000\", \"000\", \"000\", \"000\", \"000\",…\n$ FER            &lt;fct&gt; 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0…\n$ HHL            &lt;fct&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ HISPEED        &lt;fct&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ JWTRNS         &lt;fct&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 11, 0, 0, 0, 0, 0, …\n$ SCH            &lt;fct&gt; 1, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2…\n$ SCHL           &lt;fct&gt; 14, 17, 19, 12, 13, 18, 16, 12, 18, 16, 21, 15, 21, 13,…\n$ SEX            &lt;fct&gt; 1, 1, 1, 2, 2, 1, 2, 1, 1, 1, 1, 2, 2, 2, 1, 1, 2, 2, 1…\n$ state          &lt;chr&gt; \"08\", \"08\", \"08\", \"08\", \"08\", \"08\", \"08\", \"08\", \"08\", \"…\n$ year           &lt;dbl&gt; 2021, 2021, 2021, 2021, 2021, 2021, 2021, 2021, 2021, 2…\n$ FER_label      &lt;chr&gt; \"N/A (less than 15 years/greater than 50 years/ male)\",…\n$ HHL_label      &lt;chr&gt; \"N/A (GQ/vacant)\", \"N/A (GQ/vacant)\", \"N/A (GQ/vacant)\"…\n$ HISPEED_label  &lt;chr&gt; \"N/A (GQ/vacant/no paid access to the internet)\", \"N/A …\n$ JWTRNS_label   &lt;chr&gt; \"N/A (not a worker-not in the labor force, including pe…\n$ SCH_label      &lt;chr&gt; \"No, has not attended in the last 3 months\", \"No, has n…\n$ SCHL_label     &lt;chr&gt; \"Grade 11\", \"GED or alternative credential\", \"1 or more…\n$ SEX_label      &lt;chr&gt; \"Male\", \"Male\", \"Male\", \"Female\", \"Female\", \"Male\", \"Fe…\n$ JWAP_mid_label &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, \"06:07 AM\", NA, \"09…\n$ JWDP_mid_label &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, \"06:02 AM\", NA, \"09…\n\n# test function: different years and variables\ntest2_output_data &lt;- MultiYear_API_Builder(\n  years   = c(2016,2017),\n  numvars = c(\"AGEP\"),\n  catvars = c(\"HISPEED\",\"SCHL\"),\n  geo_level = \"state\",\n  geo_subset = \"37\"\n)\nglimpse(test2_output_data)\n\nRows: 200,829\nColumns: 8\n$ PWGTP         &lt;int&gt; 12, 17, 68, 83, 343, 303, 268, 65, 43, 42, 71, 63, 81, 1…\n$ AGEP          &lt;int&gt; 71, 67, 27, 81, 47, 37, 9, 63, 33, 29, 51, 55, 20, 40, 3…\n$ HISPEED       &lt;fct&gt; 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1,…\n$ SCHL          &lt;fct&gt; 21, 21, 16, 16, 22, 21, 6, 18, 13, 17, 21, 21, 19, 22, 2…\n$ state         &lt;chr&gt; \"37\", \"37\", \"37\", \"37\", \"37\", \"37\", \"37\", \"37\", \"37\", \"3…\n$ year          &lt;dbl&gt; 2016, 2016, 2016, 2016, 2016, 2016, 2016, 2016, 2016, 20…\n$ HISPEED_label &lt;chr&gt; \"Yes\", \"Yes\", \"N/A (GQ/vacant/no paid access to the inte…\n$ SCHL_label    &lt;chr&gt; \"Bachelor's degree\", \"Bachelor's degree\", \"Regular high …"
  },
  {
    "objectID": "ST558_Project1.html#summary-function-for-census-tibbles",
    "href": "ST558_Project1.html#summary-function-for-census-tibbles",
    "title": "ST 558 Project 1",
    "section": "Summary Function for Census Tibbles",
    "text": "Summary Function for Census Tibbles\nThe purpose of the function is to summarize census-class tibbles. Numeric variables are summarized by means and standard deviations while categorical variables are summarized by counts of the factors. The function was constructed as follows:\n\nSetting the function to take three arguments:\n\nCensus-class tibble, like the ones generated by the API function above, checking to confirm a valid entry\nNumeric variables to summarize, entered as a vector and checked for validity, with default being to summarize all numeric variables except PWGTP\nCategorical vectors to summarize, entered as a vector and checked for validity, with default being to summarize all categorical variables\n\nCycle through numeric variables to calculate means and standard deviations (the numeric values representing NA but coded as integers - usually 0 - are filtered)\nCycle through categorical variables to calculate counts by factor levels (for a selected categorical variable, NA values are filtered out and weights are summarized for each category)\nStore results in vectors and output results as a named list of vectors with named elements\n\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ forcats 1.0.0     ✔ readr   2.1.5\n✔ ggplot2 3.5.2     ✔ tidyr   1.3.1\n✔ purrr   1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter()  masks stats::filter()\n✖ purrr::flatten() masks jsonlite::flatten()\n✖ dplyr::lag()     masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nsummary.census &lt;- function(output_data,\n                           numvars = c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWMNP\"), #no JWAP or JWDP\n                           catvars = c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\")) {\n  \n  #check inputs:\n  \n  #  check tibble: \n  if (class(output_data)[1] != \"census\" | is_tibble(output_data) != TRUE)\n    stop(\"Please enter a valid census-class tibble\")\n  \n  #  check numvars:\n  numvar_options &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWAP\", \"JWDP\", \"JWMNP\")\n  if(!all(numvars %in% numvar_options))\n    stop(\"Please enter one or more valid numeric variables, or enter no numeric variables to accept default. Default is all numeric variables options.\")\n  \n  #  check catvars:\n  catvar_options &lt;- c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\")\n  if(!all(catvars %in% catvar_options))\n    stop(\"Please enter one or more valid categorical variables, or enter no categorical variables to accept default. Default is all categorical variables.\")\n  \n  #  cycle through numvars to calculate mean and sd,\n  # filtering for NA-type values coded as integers in numeric variables:\n  \n  mean_vector &lt;- vector()\n  sd_vector &lt;- vector()\n  \n  \n  for(i in 1:length(numvars)) {\n    if (numvars[i] == \"AGEP\") {\n      A &lt;- output_data |&gt; filter(AGEP &gt; 0) |&gt; select(AGEP)\n      B &lt;- output_data |&gt; filter(AGEP &gt; 0) |&gt; select(PWGTP)\n      mean_vector[i] &lt;- sum(A*B)/sum(B)\n      names(mean_vector)[i] &lt;- \"AGEP\"\n      sd_vector[i] &lt;- sqrt(sum(A**2*B)/sum(B)-mean_vector[i]**2)\n      names(sd_vector)[i] &lt;- (\"AGEP\")\n    }\n  }\n  for(i in 1:length(numvars)) {\n    if (numvars[i] == \"GASP\") {\n      A &lt;- output_data |&gt; filter(GASP &gt; 3) |&gt; select(GASP)\n      B &lt;- output_data |&gt; filter(GASP &gt; 3) |&gt; select(PWGTP)\n      mean_vector[i] &lt;- sum(A*B)/sum(B)\n      names(mean_vector)[i] &lt;- \"GASP\"\n      sd_vector[i] &lt;- sqrt(sum(A**2*B)/sum(B)-mean_vector[i]**2)\n      names(sd_vector)[i] &lt;- (\"GASP\")\n    }\n  }\n  for(i in 1:length(numvars)) {\n    if (numvars[i] == \"GRPIP\") {\n      A &lt;- output_data |&gt; filter(GRPIP &gt; 0) |&gt; select(GRPIP)\n      B &lt;- output_data |&gt; filter(GRPIP &gt; 0) |&gt; select(PWGTP)\n      mean_vector[i] &lt;- sum(A*B)/sum(B)\n      names(mean_vector)[i] &lt;- \"GRPIP\"\n      sd_vector[i] &lt;- sqrt(sum(A**2*B)/sum(B)-mean_vector[i]**2)\n      names(sd_vector)[i] &lt;- (\"GRPIP\")\n    }\n  }\n  for(i in 1:length(numvars)) {\n    if (numvars[i] == \"JWMNP\") {\n      A &lt;- output_data |&gt; filter(JWMNP &gt; 0) |&gt; select(JWMNP)\n      B &lt;- output_data |&gt; filter(JWMNP &gt; 0) |&gt; select(PWGTP)\n      mean_vector[i] &lt;- sum(A*B)/sum(B)\n      names(mean_vector)[i] &lt;- \"JWMNP\"\n      sd_vector[i] &lt;- sqrt(sum(A**2*B)/sum(B)-mean_vector[i]**2)\n      names(sd_vector)[i] &lt;- (\"JWMNP\")\n    }\n  }\n\n  #______________________________________\n  # loop through cat vars to select user-selected cat var\n  # filter out NA values for selected catvar\n  # groups cat var by categories, and summarizes weights for each category  \n  CatCounts &lt;- lapply(catvars, function(catvar) {\n    output_data |&gt;\n      select(all_of(catvar), PWGTP) |&gt;\n      filter(!is.na(.data[[catvar]])) |&gt;\n      group_by(.data[[catvar]]) |&gt;\n      summarise(weighted_count = sum(PWGTP, na.rm = TRUE),.groups = \"drop\")\n  })\n  names(CatCounts) &lt;- catvars\n  #______________________________________\n  \n  list(\"Means\" = mean_vector, \"StandardDeviations\" = sd_vector, \"CatCounts\" = CatCounts)\n}   \n\nRun summary.census function:\n\nsummary.census(output_data, \n               numvars = c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWMNP\"),\n               catvars = c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\"))\n\n$Means\n     AGEP      GASP     GRPIP     JWMNP \n 39.05716 103.30367  38.71732  25.04320 \n\n$StandardDeviations\n     AGEP      GASP     GRPIP     JWMNP \n 22.17451 146.30671  26.78575  20.98863 \n\n$CatCounts\n$CatCounts$FER\n# A tibble: 3 × 2\n  FER   weighted_count\n  &lt;fct&gt;          &lt;int&gt;\n1 0            8820863\n2 1             132880\n3 2            2698252\n\n$CatCounts$HHL\n# A tibble: 6 × 2\n  HHL   weighted_count\n  &lt;fct&gt;          &lt;int&gt;\n1 0             234302\n2 1            8809710\n3 2            1738516\n4 3             409337\n5 4             307834\n6 5             152296\n\n$CatCounts$HISPEED\n# A tibble: 3 × 2\n  HISPEED weighted_count\n  &lt;fct&gt;            &lt;int&gt;\n1 0               803099\n2 1              9489257\n3 2              1359639\n\n$CatCounts$JWTRNS\n# A tibble: 13 × 2\n   JWTRNS weighted_count\n   &lt;fct&gt;           &lt;int&gt;\n 1 0             5540671\n 2 1             4386646\n 3 10             150292\n 4 11            1361294\n 5 12              58543\n 6 2               62334\n 7 3                2877\n 8 4                2142\n 9 5               18037\n10 6                1221\n11 7                4219\n12 8                9269\n13 9               54450\n\n$CatCounts$SCH\n# A tibble: 4 × 2\n  SCH   weighted_count\n  &lt;fct&gt;          &lt;int&gt;\n1 0             358024\n2 1            8549852\n3 2            2353476\n4 3             390643\n\n$CatCounts$SCHL\n# A tibble: 25 × 2\n   SCHL  weighted_count\n   &lt;fct&gt;          &lt;int&gt;\n 1 0             358024\n 2 1             348921\n 3 10            173434\n 4 11            208335\n 5 12            207050\n 6 13            213278\n 7 14            274342\n 8 15            167820\n 9 16           1672849\n10 17            344239\n# ℹ 15 more rows\n\n$CatCounts$SEX\n# A tibble: 2 × 2\n  SEX   weighted_count\n  &lt;fct&gt;          &lt;int&gt;\n1 1            5905339\n2 2            5746656"
  },
  {
    "objectID": "ST558_Project1.html#generic-plot-function-for-census-tibbles",
    "href": "ST558_Project1.html#generic-plot-function-for-census-tibbles",
    "title": "ST 558 Project 1",
    "section": "Generic Plot Function for Census Tibbles",
    "text": "Generic Plot Function for Census Tibbles\nThe purpose of the function is to plot census-class tibbles. User selects the census tibble, a numeric variable and categorical variable from the tibble from which to generate box plots. The box plot shows summaries for the selected numeric variable by factor level of the selected categorical variable. The function was constructed as follows:\n\nSetting the function to take three user-selected arguments of census tibble, a numeric variable and a categorical variable, checking for validity of all inputs\nFiltering out the numeric values coded as integers but representing NA values (usually 0)\nGenerating box plots\n\n\nlibrary(tidyverse)\n\nplot.census &lt;- function(output_data, numvar, catvar) {\n  \n  #  check tibble \n  if (class(output_data)[1] != \"census\" | is_tibble(output_data) != TRUE) {\n    stop(\"Please enter a valid census-class tibble\")\n    return(NA)\n  }\n  \n  #  check numvar\n  numvar_options &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"JWAP\", \"JWDP\", \"JWMNP\")\n  if(numvar %in% numvar_options != TRUE) {\n    stop(\"Please enter one valid numeric variable\")\n  }\n  \n  #  check catvar\n  catvar_options &lt;- c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\")\n  if(catvar %in% catvar_options != TRUE) {\n    stop(\"Please enter one valid categorical variable\")\n  }\n  \n#Subset numvar to get rid of NA-type values and plot\n  \n  if (numvar == \"AGEP\") {\n    output_data |&gt; \n    subset(AGEP &gt; 0) |&gt;\n    ggplot(aes(x = get(catvar),y = AGEP, weight = PWGTP)) +\n    geom_boxplot()+\n    labs(x = catvar,y = \"Age\")\n  } else if (numvar == \"GASP\") {\n    output_data |&gt; \n    subset(GASP &gt; 3) |&gt;\n    ggplot(aes(x = get(catvar),y = GASP, weight = PWGTP)) +\n    geom_boxplot()+\n    labs(x = catvar,y = \"Monthly Gas Expense\")\n  } else if (numvar == \"GRPIP\") {\n    output_data |&gt; \n    subset(GRPIP &gt; 0) |&gt;\n    ggplot(aes(x = get(catvar),y = GRPIP, weight = PWGTP)) +\n    geom_boxplot()+\n    labs(x = catvar,y = \"Gross Rent as a Percentage of Household Income\")\n  } else if (numvar == \"JWMNP\") {\n    output_data |&gt; \n    subset(JWMNP &gt; 0) |&gt;\n    ggplot(aes(x = get(catvar),y = JWMNP, weight = PWGTP)) +\n    geom_boxplot()+\n    labs(x = catvar,y = \"Travel time to work\")\n  } else {\n    stop(\"Error!\")\n  }\n}"
  },
  {
    "objectID": "ST558_Project1.html#run-plot-function",
    "href": "ST558_Project1.html#run-plot-function",
    "title": "ST 558 Project 1",
    "section": "Run Plot Function",
    "text": "Run Plot Function\n\ndata_to_plot &lt;- MultiYear_API_Builder(\n  years   = c(2022),\n  numvars = c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWMNP\"),\n  catvars = c(\"JWAP\", \"JWDP\",\"FER\",\"HHL\",\"HISPEED\",\"JWTRNS\",\"SCH\",\"SCHL\",\"SEX\"),\n  geo_level = \"state\",\n  geo_subset = \"08\"\n)\n\nplot.census(data_to_plot, \"GASP\", \"HHL\")"
  },
  {
    "objectID": "ST558_Project1.html#investigation",
    "href": "ST558_Project1.html#investigation",
    "title": "ST 558 Project 1",
    "section": "Investigation",
    "text": "Investigation\nWe chose to use our functions to address the question of whether men or women traveled a longer time to work in 2022, the most recent year included in the data. In the results below we can see that the overall average time to work is about twenty-five minutes, with a comparatively large standard deviation around twenty-one minutes. This result includes responses from a total of almost three million men and three million women, not all of whom actually traveled to work. From the plot it seems like men and women’s travel time to work overlapped almost completely.\n\nsummary.census(output_data, \n                 numvars = c(\"JWMNP\"),\n                 catvars = c(\"SEX\")\n                 )\n\n$Means\n  JWMNP \n25.0432 \n\n$StandardDeviations\n   JWMNP \n20.98863 \n\n$CatCounts\n$CatCounts$SEX\n# A tibble: 2 × 2\n  SEX   weighted_count\n  &lt;fct&gt;          &lt;int&gt;\n1 1            5905339\n2 2            5746656\n\nplot.census(output_data, \"JWMNP\", \"SEX\")"
  }
]